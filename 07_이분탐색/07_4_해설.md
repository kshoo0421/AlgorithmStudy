# 2467 : 용액
- 문제 링크: [2467](https://www.acmicpc.net/problem/2467)

## 문제
### 내용
KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다. 산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.

같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다. 

예를 들어, 주어진 용액들의 특성값이 [-99, -2, -1, 4, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액의 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.

산성 용액과 알칼리성 용액의 특성값이 정렬된 순서로 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.

### 입력
첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하의 정수이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 오름차순으로 입력되며, 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 서로 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.

### 출력
첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.

## 풀이
### 풀이 코드
```cpp
/* [풀이]
1. 절대값을 기준으로 map에 값 저장. <절대값, 양수 여부>
2. 우선순위 큐에 절대값 기준으로 삽입. => 절대값 내림차순
3. 절대값이 같은 값이 있다면 합이 0이므로 종료
4. 총 3가지 케이스 체크
1) abs(양수 + 양수)가 최소값인 경우
2) abs(음수 + 음수)가 최소값인 경우
3) abs(양수 + 음사)가 최소값인 경우
5. 최종 결과값 출력 
*/
#include <bits/stdc++.h>
using namespace std;

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	int N, input;
	cin >> N;
	map<int, bool> isPlus;
	priority_queue<int> pqi;
	for (int i = 0; i < N; i++) {
		cin >> input;
		if (isPlus.find(abs(input)) != isPlus.end()) { // 반대편 절대값이 있다면 합이 0
			cout << -1 * input << " " << input;
			return 0; // 프로그램 종료
		}
		isPlus[abs(input)] = (input > 0);
		pqi.push(abs(input));
	}

	int plus = -1, minus = -1, minimum = INT_MAX, cur;
	pair<int, int> result;
	
	while (!pqi.empty()) {
		cur = pqi.top();
		pqi.pop();
		if (isPlus[cur]) { // 양수라면
			if ((plus != -1) && (plus + cur < minimum)) { // 두 양수의 합이 현재 최소값보다 작다면
				minimum = plus + cur; // 값 업데이트
				result = { cur, plus };
			}
			plus = cur; // 양수값 업데이트
		}
		else {
			if ((minus != -1) && (minus + cur < minimum)) { // 두 음수의 합의 절대값이 최소값보다 작다면
				minimum = minus + cur; // 값 업데이트
				result = { -1 * minus, -1 * cur };
			}
			minus = cur; // 음수값 업데이트
		}
		if (plus == -1 || minus == -1) continue; // 둘 중 하나라도 초기 값이면 종료
		if (abs(plus - minus) < minimum) {
			minimum = abs(plus - minus);
			result = { -1 * minus, plus };
		}
	}
	cout << result.first << " " << result.second;
}
```