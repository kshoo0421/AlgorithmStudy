# 다이나믹 프로그래밍 알고리즘
- 바킹독의 강의 : [다이나믹 프로그래밍 알고리즘](https://youtu.be/5leTtB3PQu0?si=w4DC90D7FjdA2nNw)<br>

`다이나믹 프로그래밍(DP)` 는 중복된 연산을 피하기 위해<br>
이미 한 연산을 기록하며 풀어가는 알고리즘입니다.<br>

각 문제별로 점화식이 다르기에 `점화식`을 생각해내는 것이 핵심이며<br>
`점화식`의 구현 자체는 어렵지 않은 경우가 대부분입니다.<br>

다만 `점화식`을 떠올리는 것이 문제별로 편차가 심한 편이며,<br>
쉽게 떠올리면 쉽게 풀고, 안떠오르면 끝까지 못풀 수도 있습니다.<br>

많은 문제를 풀어보며 감을 익히는 것이 중요한 문제 유형입니다.<br>

---

다이나믹 프로그래밍(Dynamic Programming, DP)은  
문제를 **부분 문제로 나누고,** 그 부분 문제들의 **해답을 재사용**하여 전체 문제의 해답을 효율적으로 구하는 알고리즘 설계 기법입니다.  
즉, 동일한 부분 문제들이 여러 번 반복되어 계산되는 문제에서, 이전에 계산한 결과를 저장(메모이제이션)하거나, 점화식을 이용해  
아랫단계부터 차례대로 해결(바텀업)함으로써 중복 계산을 피합니다.

---

### 주요 개념

1. **최적 부분 구조 (Optimal Substructure)**  
   - 문제의 최적 해가 그 하위 문제들의 최적 해로 구성될 수 있는 경우, 다이나믹 프로그래밍을 사용할 수 있습니다.
   - 예를 들어, 피보나치 수열의 경우 *F(n) = F(n-1) + F(n-2)* 로, *n*번째 수는 그 이전 두 수의 최적(정확한) 해로부터 구할 수 있습니다.

2. **중복 부분 문제 (Overlapping Subproblems)**  
   - 문제를 작은 부분 문제로 나눴을 때, 같은 부분 문제가 여러 번 등장하는 경우입니다.
   - 이런 경우에 다이나믹 프로그래밍은 한 번 계산한 값을 저장해두고, 필요한 곳에서 재사용함으로써 전체 연산량을 획기적으로 줄입니다.

---

### 구현 방식

다이나믹 프로그래밍은 보통 두 가지 방식으로 구현합니다.

1. **Top-down (메모이제이션) 방식**  
   - 재귀를 이용해 문제를 해결하면서, 각 부분 문제의 결과를 메모이제이션(일종의 캐시)에 저장합니다.
   - 이후 동일한 부분 문제가 다시 등장하면, 저장된 결과를 바로 재사용합니다.
   - 예를 들어, 피보나치 수열을 계산할 때, 이미 계산한 *F(5)* 값을 또 계산하지 않고 저장된 값을 사용하는 방식입니다.

2. **Bottom-up (반복문) 방식**  
   - 작은 부분 문제부터 차례대로 해결해 나가면서, 결과를 테이블(보통 배열)에 저장합니다.
   - 이 테이블을 바탕으로 점차 큰 문제를 해결하면서, 결국 전체 문제의 해답을 구합니다.
   - 예를 들어, 피보나치 수열을 반복문을 통해 *F(1)* 과 *F(2)* 에서 시작해 *F(n)* 까지 차례대로 계산하는 방식입니다.

---

### 예시: 피보나치 수열

- **재귀 + 메모이제이션 (Top-Down)**

  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;

  long long fib(int n, vector<long long> &memo) {
      if(n <= 1) return n;
      if(memo[n] != -1) return memo[n];
      memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
      return memo[n];
  }

  int main(){
      int n = 50;
      vector<long long> memo(n + 1, -1);
      cout << fib(n, memo) << "\n";
      return 0;
  }
  ```

- **반복문 (Bottom-Up)**

  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;

  int main(){
      int n = 50;
      vector<long long> dp(n + 1, 0);
      dp[0] = 0;
      dp[1] = 1;
      for (int i = 2; i <= n; i++){
          dp[i] = dp[i - 1] + dp[i - 2];
      }
      cout << dp[n] << "\n";
      return 0;
  }
  ```

---

### 요약

- **다이나믹 프로그래밍(DP)은** 문제를 작은 부분 문제로 나누고, 각 부분 문제의 해답을 저장하여, 중복 계산을 피함으로써 효율적으로 전체 문제를 해결하는 방법입니다.
- **Top-down 방식**은 재귀와 메모이제이션을 사용하고,  
- **Bottom-up 방식**은 반복문과 테이블 채우기를 사용합니다.
- DP는 **최적 부분 구조**와 **중복 부분 문제** 조건이 만족되는 문제에서 매우 유용합니다.