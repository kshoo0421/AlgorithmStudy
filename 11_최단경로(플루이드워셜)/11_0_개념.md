# 최단경로 알고리즘(플루이드 워셜)
- 바킹독의 강의 : [플루이드 알고리즘](https://youtu.be/dDDy2bEZRA8?si=igbKfFTVLCQrmliu)<br>

뱡향 그래프의 최단경로 문제에서는 여러 알고리즘을 활용할 수 있습니다.<br>
주로 3가지 알고리즘 풀이 방법을 활용합니다.<br>
그 중에서도 `플루이드 워셜 알고리즘`은 사용 빈도가 높기에 풀이 방법을 알고 계셔야 합니다.<br>

앞서 다뤘던 `DP`를 활용한 알고리즘입니다.<br>
구현은 굉장히 단순한 편이지만, 단순 코드만 보면 이해가 되지 않는 경우도 많습니다.<br>
직접 노트에 표를 그려보며 이해하는 것을 추천합니다.<br>

---

플루이드 워셜(Floyd-Warshall) 알고리즘은  
**모든 쌍의 최단 경로(All-Pairs Shortest Paths, APSP)** 문제를 해결하기 위한 대표적인 동적 계획법 알고리즘입니다.  
즉, 주어진 그래프의 모든 정점 쌍 \((i, j)\)에 대해, \(i\)에서 \(j\)로 가는 최단 경로의 거리를 계산합니다.

---

## 1. 알고리즘 기본 아이디어

- **동적 계획법(DP) 접근**:  
  그래프의 정점 집합을 \(\{1, 2, \ldots, n\}\)라 할 때,  
  \(d_{ij}^{(k)}\)를 정점 \(1\)부터 \(k\)까지의 정점을 경유했을 때, \(i\)에서 \(j\)로 가는 최단 거리를 나타낸다고 정의합니다.

- **점화식**:  
  정점 \(k\)를 중간에 거치는 경우를 고려하면  
  \[
    d_{ij}^{(k)} = \min\left( d_{ij}^{(k-1)},\, d_{ik}^{(k-1)} + d_{kj}^{(k-1)} \right)
  \]
  여기서  
  - \(d_{ij}^{(0)}\)는 \(i\)와 \(j\) 사이의 직접 간선의 가중치이며, 간선이 없으면 보통 무한대(\(\infty\))로 초기화합니다.
  - 점화식은 "정점 \(k\)를 경유하는 것이 \(i\)와 \(j\) 사이의 기존 최단 경로보다 짧으면, 그 경로를 선택"하는 방식입니다.

- **최종 해**:  
  모든 정점 \((i, j)\)에 대해 \(d_{ij}^{(n)}\)을 계산하면, 이는 \(i\)에서 \(j\)로 가는 최단 경로의 거리를 나타냅니다.

---

## 2. 알고리즘 단계

1. **초기화**:  
   - \(n\)개의 정점을 가진 그래프에서, \(d[i][j]\) 행렬을 만듭니다.
   - 만약 \(i = j\)이면 \(d[i][j] = 0\),  
     만약 \(i\)와 \(j\) 사이에 간선이 있다면 \(d[i][j]\)는 해당 간선의 가중치,  
     간선이 없다면 \(d[i][j] = \infty\) (또는 매우 큰 값)으로 초기화합니다.

2. **동적 계획법 진행**:  
   - \(k\)를 \(1\)부터 \(n\)까지 반복하면서,  
   - 모든 정점 \(i\)와 \(j\)에 대해  
     \[
       d[i][j] = \min(d[i][j],\ d[i][k] + d[k][j])
     \]
   - 이 과정을 통해, 정점 \(k\)를 경유하는 최단 경로들을 단계별로 반영합니다.

3. **결과 확인**:  
   - 최종적으로 \(d[i][j]\)에 모든 정점 \(i, j\) 쌍의 최단 경로 길이가 저장됩니다.
   - 만약 특정 \(d[i][j]\)가 여전히 무한대이면, \(i\)에서 \(j\)로의 경로가 없음을 의미합니다.

---

## 3. 시간 복잡도 및 특징

- **시간 복잡도**:  
  세 개의 중첩 반복문을 사용하므로 시간 복잡도는 \(O(n^3)\)입니다.  
  \(n\)이 작거나, \(n\)의 최대값이 수백 정도라면 문제가 없지만, \(n\)이 매우 크면 효율적이지 않을 수 있습니다.

- **메모리 복잡도**:  
  \(O(n^2)\)의 메모리를 사용하며, \(n \times n\) 행렬을 필요로 합니다.

- **모든 쌍 최단 경로**:  
  한 번의 실행으로 그래프에 있는 모든 정점 쌍의 최단 경로를 구할 수 있습니다.
- **간단하고 구현이 직관적**입니다.

---

## 4. C++ 코드 예시

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int INF = 1e9;  // 그래프의 간선이 없을 때 사용할 큰 값 (문제에 따라 조정)

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int V, E;
    cin >> V >> E;
    // V: 정점의 수, E: 간선의 수
    // d[i][j]를 저장할 2차원 벡터, 0-based index 사용
    vector<vector<int>> d(V, vector<int>(V, INF));

    // 자기 자신에 대해서는 0으로 초기화
    for (int i = 0; i < V; i++){
        d[i][i] = 0;
    }
    
    // 간선 정보 입력: u, v, w
    // 간선이 여러 개 있을 수 있지만, 가장 작은 가중치로 갱신
    for (int i = 0; i < E; i++){
        int u, v, w;
        cin >> u >> v >> w;
        // u와 v는 양방향 그래프라고 가정 (문제에 따라 다름)
        d[u][v] = min(d[u][v], w);
        d[v][u] = min(d[v][u], w);
    }
    
    // 플루이드 워셜 알고리즘 수행
    for (int k = 0; k < V; k++){
        for (int i = 0; i < V; i++){
            for (int j = 0; j < V; j++){
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }
    
    // 결과 출력: 모든 정점 쌍 (i, j) 최단 경로 거리 출력 (예시)
    for (int i = 0; i < V; i++){
        for (int j = 0; j < V; j++){
            if(d[i][j] == INF) cout << "INF ";
            else cout << d[i][j] << " ";
        }
        cout << "\n";
    }
    
    return 0;
}
```

### 설명

- **초기화**:  
  \(V \times V\) 행렬 `d`를 INF로 채우고, 자기 자신(\(i = j\))는 0으로 초기화합니다.
- **간선 입력**:  
  각 간선에 대해, 양방향인 경우 두 값 모두 업데이트합니다.
- **플루이드 워셜**:  
  세 개의 중첩 반복문을 통해 \(i, j\) 사이의 최단 경로를 계산합니다.
- **출력**:  
  각 정점 쌍 \(i, j\)의 최단 경로 거리를 출력합니다.

---

이와 같이, **플루이드 워셜 알고리즘**은 모든 쌍의 최단 경로를 구하는 데 매우 직관적인 방식이며, 구현도 간단합니다. 다만, \(O(V^3)\)의 시간 복잡도가 있으므로 정점 수가 매우 많을 경우에는 사용하기 어렵습니다.