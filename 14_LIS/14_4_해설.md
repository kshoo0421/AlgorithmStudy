# 1365 : 
- 문제 링크: [1365](https://www.acmicpc.net/problem/1365)

## 문제
### 내용
공화국에 있는 유스타운 시에서는 길을 사이에 두고 전봇대가 아래와 같이 두 줄로 늘어서 있다. 그리고 길 왼편과 길 오른편의 전봇대는 하나의 전선으로 연결되어 있다. 어떤 전봇대도 두 개 이상의 다른 전봇대와 연결되어 있지는 않다.

![14_3_1](../image/14_3_1.png)

문제는 이 두 전봇대 사이에 있는 전깃줄이 매우 꼬여 있다는 점이다. 꼬여있는 전깃줄은 화재를 유발할 가능성이 있기 때문에 유스타운 시의 시장 임한수는 전격적으로 이 문제를 해결하기로 했다.

임한수는 꼬여 있는 전깃줄 중 몇 개를 적절히 잘라 내어 이 문제를 해결하기로 했다. 하지만 이미 설치해 놓은 전선이 아깝기 때문에 잘라내는 전선을 최소로 하여 꼬여 있는 전선이 하나도 없게 만들려고 한다.

유스타운 시의 시장 임한수를 도와 잘라내야 할 전선의 최소 개수를 구하는 프로그램을 작성하시오.

### 입력
첫 줄에 전봇대의 개수 N(1 ≤ N ≤ 100,000)이 주어지고, 이어서 N보다 작거나 같은 자연수가 N개 주어진다. i번째 줄에 입력되는 자연수는 길 왼쪽에 i번째 전봇대와 연결된 길 오른편의 전봇대가 몇 번 전봇대인지를 나타낸다.

### 출력
전선이 꼬이지 않으려면 최소 몇 개의 전선을 잘라내야 하는 지를 첫째 줄에 출력한다.

## 풀이
### 풀이 코드
```cpp
/*
1. 값이 들어올 때마다 해당 값보다 큰 값이 있는지 확인하는 LIS 풀이법입니다.
3번과 동일합니다.
*/
#include <bits/stdc++.h>
using namespace std;

int main()
{
    ios::sync_with_stdio(0), cin.tie(0);
    int N;
    cin >> N;
    vector<int> saved; // 최장 증가 부분 수열(LIS)를 구성하는 후보를 저장하는 벡터

    // N개의 전선 연결 정보를 반복 처리
    while (N--) {
        int i;
        cin >> i; // 오른쪽 전봇대 번호를 입력받음
        // saved 벡터에서 현재 입력 i보다 큰 값이 처음 등장하는 위치를 찾음 (upper_bound 사용)
        auto it = upper_bound(saved.begin(), saved.end(), i);
        if (it == saved.end())
            // 만약 saved 내에 i보다 큰 값이 없다면, 현재 i를 가장 뒤에 추가 (증가 수열 확장)
            saved.push_back(i);
        else
            // 그렇지 않다면, i보다 큰 값 중 가장 왼쪽 위치의 값을 i로 대체하여 
            // 앞으로 더 긴 증가 부분 수열을 구성할 수 있도록 함
            *it = i;
    }

    // saved 벡터의 크기는 입력된 전선들 중 꼬이지 않게 남겨둘 수 있는 전선(증가 수열)의 최대 개수를 나타냄
    // 문제에서는 최소 잘라내야 할 전선의 개수를 요구하는데,
    // 그 값은 전체 전선 개수에서 최대 남길 수 있는 전선의 개수를 뺀 값이므로,
    // 여기서는 최대 남겨둘 수 있는 전선의 개수, 즉 LIS의 길이를 출력함.
    cout << saved.size();
}
```