# LIS(최장 증가 부분 수열) 알고리즘
`LIS(최장 증가 부분 수열)`는 여러 알고리즘을 활용하여 문제를 풀 수 있습니다.<br>
보통 `DP`, `이분탐색` 알고리즘으로 많이 풀며, 시간복잡도가 여유로운 문제라면 다른 방식으로도 충분히 풀 수 있습니다.<br>
알고리즘 유형의 막바지인 만큼 기존의 알고리즘을 복습한다고 생각하셔도 좋습니다.<br>
배열을 이해하고 활용하는 데에 좋은 문제유형이라고 생각해 넣게 되었습니다.<br>


---

LIS(Longest Increasing Subsequence, 최장 증가 부분 수열) 문제 유형은 주어진 수열에서  
"순서대로 증가하는 부분 수열" 중 가장 긴 것을 찾는 문제입니다. 이 문제 유형은 동적 계획법(Dynamic Programming, DP)을 비롯해 이분 탐색(Binary Search) 기법 등 여러 가지 알고리즘 기법을 사용하여 풀 수 있습니다. 아래에서 LIS 문제의 정의, 알고리즘 접근법, 그리고 문제 해결 시 자주 등장하는 변형 및 응용에 대해 설명하겠습니다.

---

## 1. 문제 정의 및 예시

- **문제 정의**  
  주어진 수열 \( A = \{a_1, a_2, \dots, a_n\} \)에서,  
  인덱스 순서를 유지하며 (즉, 원래 순서를 깨지 않고),  
  \( a_{i_1} < a_{i_2} < \dots < a_{i_k} \) ( \( i_1 < i_2 < \dots < i_k \) )를 만족하는 부분 수열 중,  
  가장 길이가 긴 부분 수열을 찾는 문제입니다.

- **예시**  
  예를 들어, 수열 \([10, 20, 10, 30, 20, 50]\)에서  
  가능한 증가 부분 수열의 예로는 \([10, 20, 30, 50]\)과 \([10, 10, 30, 50]\) 등이 있으나,  
  가장 긴 증가 부분 수열은 \([10, 20, 30, 50]\) (길이 4)로 알려져 있습니다.

---

## 2. 대표적인 알고리즘 접근 방법

### A. 동적 계획법 (DP) 방법
- **아이디어**:  
  각 원소 \(a_i\)에 대해,  
  \(dp[i]\)를 "끝이 \(a_i\)인 최장 증가 부분 수열의 길이"로 정의합니다.
- **점화식**:  
  \( dp[i] = \max\{dp[j] \,|\, 1 \le j < i \text{ and } a_j < a_i\} + 1 \)  
  만약 \(i\) 이전에 \(a_i\)보다 작은 원소가 없으면, \(dp[i] = 1\)입니다.
- **시간 복잡도**:  
  이중 반복문을 사용하여 계산하므로 \(O(n^2)\)입니다.
- **추가**:  
  보통는 최장 길이를 출력하거나, 실제 수열을 추적하는 방법(역추적)을 추가로 구현할 수 있습니다.

### B. 이분 탐색 (Binary Search) 방법
- **아이디어**:  
  동적 계획법의 아이디어와 함께, 현재까지 찾은 증가 부분 수열의 “끝 원소들(end elements)”을 관리하는 배열을 유지합니다.
- **방법**:  
  - 매 원소마다, 현재 유지하고 있는 증가 수열의 끝 원소 배열에서  
    원소보다 크거나 같은 첫 위치를 이분 탐색으로 찾아 바꿉니다.
  - 이 배열의 길이가 최장 증가 부분 수열의 길이가 됩니다.
- **시간 복잡도**:  
  \(O(n \log n)\)으로 매우 효율적입니다.

### 비교  
- DP 방식은 코드 구현이 직관적이지만, \(n\)이 매우 큰 경우 \(O(n^2)\)로 성능이 문제가 될 수 있습니다.
- 이분 탐색 방식은 \(O(n \log n)\)으로 훨씬 빠르게 최장 증가 부분 수열의 길이를 구할 수 있으며, 실제 문제에서도 많이 사용됩니다.

---

## 3. 문제의 변형 및 응용 사례

LIS 문제 유형은 기본 문제 외에도 다양한 변형이 있습니다.

- **최장 감소 부분 수열(Longest Decreasing Subsequence)**:  
  증가 조건을 반대로 하여 감소하는 부분 수열을 찾습니다.

- **최장 증가 부분 수열의 실제 수열 출력**:  
  길이뿐만 아니라 어떤 수열인지 역추적하여 출력하는 문제.
  
- **LIS의 개수 구하기**:  
  최장 증가 부분 수열의 길이가 같은 경우의 수를 세는 문제.
  
- **2차원 격자나 다른 자료구조에서의 증가 부분 수열 문제**:  
  예를 들어, 여러 배열 또는 행렬에서 LIS와 유사한 문제들이 출제됩니다.

- **구간 업데이트 및 질의와 결합된 문제**:  
  세그먼트 트리, BIT(Binary Indexed Tree) 등을 LIS와 결합하여 해결하는 문제도 있습니다.

---

## 요약

LIS 문제 유형은  
- 주어진 수열에서 인덱스 순서를 유지하면서 증가하는 부분 수열 중 가장 긴 것을 구하는 문제입니다.
- 대표적인 해결책은 동적 계획법 \(O(n^2)\)과 이분 탐색을 활용한 \(O(n \log n)\) 방식입니다.
- 문제에 따라 실제 수열의 출력, 경우의 수 계산, 여러 변형 문제가 출제되며, 다양한 기술(역추적, 자료구조 활용)이 요구됩니다.

LIS 알고리즘은 알고리즘 문제 해결에서 매우 중요한 기본 기술 중 하나로, 수열의 패턴 분석 및 최적 부분 구조를 이해하는 데 도움을 줍니다.