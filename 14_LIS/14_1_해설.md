# 12015 : 가장 긴 증가하는 부분 수열 2
- 문제 링크: [12015](https://www.acmicpc.net/problem/12015)

## 문제
### 내용
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

### 입력
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000,000)

### 출력
첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

## 풀이
### 풀이 코드
```cpp
/*
1. 전형적인 lis 문제, lower_bound 함수(이분탐색)를 이용해서 문제를 푼다.
*/
#include <bits/stdc++.h>
using namespace std;

int main()
{
    ios::sync_with_stdio(0), cin.tie(0);
    int n;
    cin >> n;
    vector<int> a(n, 0);
    for (int& i : a) cin >> i; // 수열의 각 원소 입력

    vector<int> lis; // 최장 증가 부분 수열(LIS)의 후보 값을 저장할 벡터

    for (int i = 0; i < n; i++) {
        // lis 벡터 내에서 현재 원소 a[i]보다 크거나 같은 가장 왼쪽 위치를 찾음 (이분 탐색)
        auto it = lower_bound(lis.begin(), lis.end(), a[i]);
        // 만약 찾은 위치가 lis의 끝이라면, a[i]는 lis의 모든 원소보다 큼 -> lis에 추가
        if (it == lis.end()) 
            lis.push_back(a[i]);
        else 
            // 그렇지 않다면, lis의 해당 위치의 값을 a[i]로 대체하여, 이후의 증가 부분 수열 후보로 활용
            *it = a[i];
    }

    cout << lis.size(); // lis 벡터의 크기가 가장 긴 증가 부분 수열의 길이
}

```

### STL : lower_bound()
`lower_bound` 함수는 정렬된 배열에서 해당 정수 이상의 값이 나오는 첫 위치를 반환하는 함수입니다.<br>
알고리즘 풀이를 할 때 필수적인 함수라고 보기는 힘들지만, 이 함수를 활용하면 코드가 확연히 짧아지는 문제들도 많이 있습니다.<br>
`LIS`에서는 보통 이 함수를 활용할 수 있기에 알고 있으면 좋습니다.<br>
비슷한 함수로, `upper_bound` 함수가 있는데, 이 함수는 정수 *초과*의 값이 나오는 첫 위치를 반환합니다.<br>
아래는 GPT의 `lower_bound` 함수 설명입니다.<br>

---

`lower_bound` 함수는 C++의 \<algorithm\> 헤더에 정의된 표준 라이브러리 함수로, **정렬된 범위** 내에서 지정한 값 이상이 되는 **첫 번째 원소**의 위치를 찾는 데 사용됩니다.

### 주요 특징
- **정렬된 범위**:  
  `lower_bound`를 사용하기 위해서는 입력 범위가 오름차순(또는 사용자 정의 비교 함수를 사용하는 경우 그에 맞는 정렬 순서)으로 정렬되어 있어야 합니다.

- **반환값**:  
  - 주어진 범위에서, **지정한 값 이상**인 첫 번째 원소를 가리키는 반복자(iterator)를 반환합니다.
  - 만약 해당 값 이상의 원소가 없으면, 범위의 끝을 가리키는 반복자(end iterator)를 반환합니다.

- **시간 복잡도**:  
  - `lower_bound` 함수는 **이분 탐색(binary search)**을 사용하므로, \(O(\log n)\)의 시간 복잡도를 가집니다.

### 사용 예시

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main(){
    vector<int> vec = {1, 3, 5, 7, 9};
    
    // 5 이상이 되는 첫 번째 원소의 위치를 찾습니다.
    auto it = lower_bound(vec.begin(), vec.end(), 5);
    
    if (it != vec.end())
        cout << "5 이상인 첫 번째 원소: " << *it << "\n";  // 출력: 5
    else
        cout << "해당 값 이상인 원소가 없습니다.\n";

    // 6 이상이 되는 첫 번째 원소 찾기
    auto it2 = lower_bound(vec.begin(), vec.end(), 6);
    
    if (it2 != vec.end())
        cout << "6 이상인 첫 번째 원소: " << *it2 << "\n"; // 출력: 7
    else
        cout << "해당 값 이상인 원소가 없습니다.\n";
    
    return 0;
}
```

### 동작 방식

- **이분 탐색**:  
  함수는 정렬된 범위에서 이분 탐색을 진행하여, 지정한 값 `val`보다 작지 않은(즉, `>= val`) 첫 번째 원소의 위치를 찾습니다.
  
- **예시 설명**:  
  위 예제에서는 정렬된 `vec`에서 5 이상인 첫 원소를 찾는데,  
  - 5가 vec의 3번째 원소이고, 5는 5 이상이므로 그 위치의 반복자가 반환됩니다.
  - 6의 경우, vec 내에서 6 이상인 원소는 7이므로 7을 가리키는 반복자가 반환됩니다.

### 요약

- `lower_bound`는 **정렬된 범위** 내에서 목표 값 이상이 되는 **첫 번째 원소**의 위치를 찾는 이분 탐색 기반 함수입니다.
- 시간 복잡도는 \(O(\log n)\)이며, 원소가 없을 경우 범위의 끝을 반환합니다.
- 주로 검색, 범위 쿼리, 이분 탐색 문제 해결에 사용됩니다.