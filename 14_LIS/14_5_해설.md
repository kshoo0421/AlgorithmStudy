# 3745 : 오름세
- 문제 링크: [3745](https://www.acmicpc.net/problem/3745)

## 문제
### 내용
주식투자를 좋아하는 정인이는 주가의 오름세를 살펴보려고 한다.

정인이는 n일 동안 매일 주가를 적어놓았고, 여기서 오름세를 찾아보려고 한다.

n일 동안의 주가를 p1, p2, ..., pn이라고 했을 때, 오름세란 부분수열 pi1 < pi2 < ... < pik (i1 < i2 < ... ik)을 말한다.

n일 동안 주가가 주어졌을 때, 가장 긴 오름세를 찾는 프로그램을 작성하시오.

### 입력
입력은 여러개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 주가를 관찰한 날의 수 N (N ≤ 100000)이 주어진다. 둘째 줄에는 관찰한 주가가 첫 날부터 순서대로 주어진다. 주가는 한 개 이상의 공백으로 구분되어 있으며, 그 외의 위치에서도 자유롭게 나올 수 있다. 주가는 100,000보다 작거나 같은 자연수이다.

### 출력
각 테스트 케이스에 대해서 입력으로 주어진 주가의 가장 긴 오름세의 길이를 출력한다.

## 풀이
### 풀이 코드
```cpp
/*
1. 값이 들어올 때마다 해당 값보다 큰 값이 있는지 확인하는 LIS 풀이법입니다.
3, 4번과 동일합니다.
*/
#include <bits/stdc++.h>
using namespace std;

int main()
{
    ios::sync_with_stdio(0), cin.tie(0);
    int N;
    // 여러 테스트 케이스가 주어지므로, cin >> N을 계속 읽음
    while (cin >> N) {
        vector<int> saved; // 현재까지의 오름차순 부분 수열(LIS 후보)을 저장하는 벡터

        // N일 동안의 주가 정보를 읽으며 처리
        for (int i = 0; i < N; i++) {
            int input;
            cin >> input; // 하루의 주가를 입력받음

            // saved 벡터 내에서 현재 input 값 이상이 되는 첫 번째 원소의 위치를 찾음
            auto it = lower_bound(saved.begin(), saved.end(), input);
            
            // 만약 saved에 input 보다 크거나 같은 원소가 없다면 (즉, it가 end라면)
            // input 값을 saved 벡터 끝에 추가하여 현재 오름차순 수열을 확장함
            if (it == saved.end()) 
                saved.push_back(input);
            else
                // 그렇지 않으면, 현재 input 값으로 해당 원소를 대체하여
                // 이후 더 긴 증가 부분 수열을 구하는 데 유리한(작은) 후보를 마련함
                *it = input;
        }
        // saved의 크기는 구한 최장 증가 부분 수열(LIS)의 길이를 의미함
        cout << saved.size() << "\n";
    }
}
``````