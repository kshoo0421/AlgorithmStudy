# 1744 : 수 묶기
- 문제 링크: [1744](https://www.acmicpc.net/problem/1744)

## 문제
### 내용
길이가 N인 수열이 주어졌을 때, 그 수열의 합을 구하려고 한다. 하지만, 그냥 그 수열의 합을 모두 더해서 구하는 것이 아니라, 수열의 두 수를 묶으려고 한다. 어떤 수를 묶으려고 할 때, 위치에 상관없이 묶을 수 있다. 하지만, 같은 위치에 있는 수(자기 자신)를 묶는 것은 불가능하다. 그리고 어떤 수를 묶게 되면, 수열의 합을 구할 때 묶은 수는 서로 곱한 후에 더한다.

예를 들면, 어떤 수열이 {0, 1, 2, 4, 3, 5}일 때, 그냥 이 수열의 합을 구하면 0+1+2+4+3+5 = 15이다. 하지만, 2와 3을 묶고, 4와 5를 묶게 되면, 0+1+(2 * 3)+(4 * 5) = 27이 되어 최대가 된다.

수열의 모든 수는 단 한번만 묶거나, 아니면 묶지 않아야한다.

수열이 주어졌을 때, 수열의 각 수를 적절히 묶었을 때, 그 합이 최대가 되게 하는 프로그램을 작성하시오.

### 입력
첫째 줄에 수열의 크기 N이 주어진다. N은 50보다 작은 자연수이다. 둘째 줄부터 N개의 줄에 수열의 각 수가 주어진다. 수열의 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

### 출력
수를 합이 최대가 나오게 묶었을 때 합을 출력한다. 정답은 항상 2^31보다 작다.

## 풀이
### 풀이 코드
```cpp
/* [풀이]
1. 양수와 음수를 따로 저장
2. 양수는 내림차순, 음수는 오름차순으로 정렬
(절댓값 기준 내림차순)
3. 양수는 (곱셈) vs (덧셈)을 비교한 후 큰 값으로 덧셈.
음수는 최대한 묶기
4. 남은 모든 수를 더하고 결과 도출
*/
#include <bits/stdc++.h>
using namespace std;

int main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	int N;
	cin >> N;
	vector<int> pos, neg; // pos : 양수(positive) / neg : 음수(negative)
	for (int i = 0; i < N; i++) {
		int input;
		cin >> input;
		if (input > 0) pos.emplace_back(input); // 0보다 크면 양수에
		else neg.emplace_back(input); // 0보다 작거나 같으면 음수에
		// 0을 음수에 넣을 경우 {(음수) * 0 } 묶음으로 총합을 늘릴 수 있음
	}
	sort(pos.rbegin(), pos.rend()); // 양수 : 내림차순
	sort(neg.begin(), neg.end()); // 음수 : 오름차순(절대값이 큰 순서)
	
	int total = 0; // 현재 총합 : 0
	// 양수 먼저
	for (int i = 0; i < pos.size(); i++) {
		if (i < pos.size() - 1) { // 다음 수가 있다면
			// (곱셈) vs (덧셈) 크기 비교
			if (pos[i] * pos[i + 1] > pos[i] + pos[i + 1]) {
				total += (pos[i] * pos[i + 1]);
				// 곱셈 시 묶였으니 i도 한 칸 더 이동
				i++;
			}
			else total += pos[i];
		}
		else total += pos[i]; // 마지막 수면 더하기
	}

	// 음수면 2개씩 묶고, 1개 남으면 해당 값 더하기
	for (int i = 0; i < neg.size(); i += 2) { // 반드시 묶으니 2칸씩
		if (i < neg.size() - 1) total += (neg[i] * neg[i + 1]);
		else total += neg[i];
	}
	cout << total; // 총합 출력
}
```