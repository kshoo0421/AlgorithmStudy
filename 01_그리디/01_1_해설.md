# 1715 : 카드 정렬하기
- 문제 링크: [1715](https://www.acmicpc.net/problem/1715)

## 문제
### 내용
정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. 이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.

매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다. 그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.

N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.

### 출력
첫째 줄에 최소 비교 횟수를 출력한다.

## 풀이
### 풀이 코드
```cpp
/* [풀이]
1. 카드의 비교횟수를 값으로 꾸준히 오름차순으로 정렬한다.
2. 가장 낮은 두 값을 카드에서 빼고, 두 값의 합을 카드에 넣는다.
3. 값이 1개가 될 때 해당 값을 출력한다.
*/
#include <bits/stdc++.h>
using namespace std;

int main()
{
    ios::sync_with_stdio(0), cin.tie(0); // 입출력 속도 향상을 위해 동기화 해제 및 cin tie 해제
    int N, sum = 0;
    cin >> N; // 카드 묶음의 개수 N을 입력받음

    multiset<int> card; // multiset을 사용하여 카드 묶음을 자동으로 오름차순 정렬하며 저장

    // N개의 카드 묶음의 크기를 입력받아 multiset에 삽입
    while(N--){
        int input;
        cin >> input;
        card.insert(input);
    }

    // 카드 묶음이 하나 남을 때까지, 가장 작은 두 묶음을 골라 합친다.
    while (card.size() > 1) {
        int cur = *(card.begin());    // 가장 작은 카드 묶음을 선택 (multiset의 첫 번째 원소)
        card.erase(card.begin());       // 선택한 가장 작은 묶음을 multiset에서 제거
        cur += *(card.begin());         // 다음으로 작은 카드 묶음을 선택하고, 그 값을 cur에 더함 (두 묶음을 합침)
        card.erase(card.begin());       // 두 번째로 작은 카드 묶음을 multiset에서 제거
        sum += cur;                     // 두 묶음을 합친 데 필요한 비교 횟수(두 묶음의 크기의 합)를 총합에 더함
        card.insert(cur);               // 합쳐진 새 카드 묶음을 multiset에 삽입 (자동으로 정렬됨)
    }
    cout << sum; // 모든 카드 묶음을 합치는 데 필요한 총 비교 횟수를 출력
}
```
### 사용된 STL 설명
`multiset`는 알고리즘에서 많이 사용되는 자료구조는 아닙니다.<br>
`set`에서 파생된 자료구조입니다.<br>

아마 비슷한 자료구조를 여러 번 보신다면 금방 공통점을 발견할 수 있을 것입니다.<br>
아래 설명은 gpt에 물어본 `multiset` 내용입니다.<br>

---

#### Multiset
`multiset`은 C++ STL(Standard Template Library)에서 제공하는 컨테이너 중 하나로, 다음과 같은 특징을 가지고 있습니다.

1. **중복 허용**  
   - `multiset`은 동일한 값을 여러 번 저장할 수 있습니다.  
   - 예를 들어, {2, 3, 2, 5}와 같이 중복된 원소가 들어갈 수 있습니다.

2. **자동 정렬**  
   - `multiset`에 삽입된 원소들은 자동으로 정렬된 순서로 저장됩니다.  
   - 기본적으로 오름차순으로 정렬되며, 커스텀 비교 함수를 제공하면 다른 순서(내림차순 등)로도 정렬할 수 있습니다.

3. **내부 자료구조**  
   - 일반적으로 균형 이진 탐색 트리(예: 레드-블랙 트리)를 사용하여 구현됩니다.  
   - 이 때문에 삽입, 삭제, 검색 등의 연산이 평균적으로 \(O(\log n)\)의 시간 복잡도를 가집니다.

4. **원소 접근**  
   - `multiset`은 인덱스 기반의 접근을 제공하지 않습니다. 대신, 반복자(iterator)를 통해 원소를 순회할 수 있습니다.
   - 예를 들어, `multiset.begin()`을 호출하면 가장 작은 원소를 가리키는 반복자를 반환하며, `multiset.end()`는 마지막 원소 다음을 가리킵니다.

5. **사용 예시**  
   - 정렬된 상태로 데이터를 관리해야 할 때,
   - 중복 원소도 저장해야 할 때,
   - 특정 값의 개수를 빠르게 세거나 범위 검색을 해야 할 때 유용합니다.

예제 코드:
```cpp
#include <iostream>
#include <set>
using namespace std;

int main(){
    multiset<int> ms;
    ms.insert(3);
    ms.insert(1);
    ms.insert(2);
    ms.insert(1);  // 중복 원소 삽입

    // 오름차순으로 출력
    for(auto x : ms){
        cout << x << " "; // 출력: 1 1 2 3
    }
    cout << "\n";

    // 특정 값 1의 개수 확인
    cout << ms.count(1) << "\n"; // 출력: 2

    return 0;
}
```

요약하면, `multiset`은 **정렬된 상태**로 원소를 저장하며 **중복을 허용**하는 컨테이너로, 효율적인 검색과 정렬된 순서가 필요할 때 유용하게 사용됩니다.