# 1339 : 단어 수학
- 문제 링크: [1339](https://www.acmicpc.net/problem/1339)

## 문제
### 내용
민식이는 수학학원에서 단어 수학 문제를 푸는 숙제를 받았다.

단어 수학 문제는 N개의 단어로 이루어져 있으며, 각 단어는 알파벳 대문자로만 이루어져 있다. 이때, 각 알파벳 대문자를 0부터 9까지의 숫자 중 하나로 바꿔서 N개의 수를 합하는 문제이다. 같은 알파벳은 같은 숫자로 바꿔야 하며, 두 개 이상의 알파벳이 같은 숫자로 바뀌어지면 안 된다.

예를 들어, GCF + ACDEB를 계산한다고 할 때, A = 9, B = 4, C = 8, D = 6, E = 5, F = 3, G = 7로 결정한다면, 두 수의 합은 99437이 되어서 최대가 될 것이다.

N개의 단어가 주어졌을 때, 그 수의 합을 최대로 만드는 프로그램을 작성하시오.

### 입력
첫째 줄에 단어의 개수 N(1 ≤ N ≤ 10)이 주어진다. 둘째 줄부터 N개의 줄에 단어가 한 줄에 하나씩 주어진다. 단어는 알파벳 대문자로만 이루어져있다. 모든 단어에 포함되어 있는 알파벳은 최대 10개이고, 수의 최대 길이는 8이다. 서로 다른 문자는 서로 다른 숫자를 나타낸다.

### 출력
첫째 줄에 주어진 단어의 합의 최댓값을 출력한다.

## 풀이
### 풀이 코드
```cpp
/* [풀이]
1. 모든 글자를 1로 가정했을 때의 값 더하기
2. 내림차순 정렬
3. 앞에서부터 9~0 할당
4. 해당 값들 모두 곱하여 누적 값에 더하기
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    int N, digit = 9, total = 0;
    // N : 단어 수 
    // digit : 현재 한 글자에 배치할 수 있는 최대 숫자(9 -> 0)
    // total : 전체 누적값(결과값)

    map<char, int> weight;
    // 1. [글자 -> 현재까지 누적값] 연결하는 해시 ex) weight['c'] = 10010
    // 2. [글자 -> 가중치] ex) weight['c'] = 9
    vector<pair<int, char>> weightV;
    // <값, 글자> 순서대로 배열(순서 : 9 -> 0)

    cin >> N;    // 단어 갯수
    
    while(N--) { // 단어 갯수만큼 반복
        string word;
        cin >> word; // 단어 입력
        for (int i = 0; i < word.size(); i++) { 
            // 단어 길이만큼 반복
            char c = word[i];
            // c : 단어의 j번째 글자
            weight[c] += pow(10, word.size() - i - 1);
            // pow(a, b) = a^b
            // 10의 자릿수만큼 weight에 추가
        }
    }

    // 정렬 위해 vector로 변환
    // mci : Map<Char, Int> / first = char , second = int
    for (auto mci : weight) weightV.push_back({ mci.second, mci.first });

    // 모든 글자 1 기준, 가중치가 큰 순서대로 정렬
    sort(weightV.rbegin(), weightV.rend());

    // pic : Pair<Int, Char> 
    for(auto& pic : weightV) { // 전체 가중치
        total += (pic.first * digit--); 
        // 전체값 += ((1 기준 가중치) * (9 -> 0 (줄어감)))
    }
    cout << total;
}
```
### 사용된 STL 설명 (by chatGPT)
`map`은 자주는 아니지만 종종 사용되는 자료구조입니다.<br>
`map`에서 파생된 자료구조도 많으므로,<br>
한 번쯤은 비교해서 공부하는 것도 필요합니다.<br>

`pow`는 거의 사용되지 않는데, 제곱할 때 사용하는 함수로 이해하면 됩니다.<br>

아래는 map에 대한 gpt 답변입니다.

---

`map`은 C++ STL의 연관 컨테이너 중 하나로, **키-값 쌍**을 저장하며 키를 기준으로 자동으로 정렬된 상태를 유지하는 자료구조입니다. 보통 **레드-블랙 트리**와 같은 균형 이진 탐색 트리로 구현되어 있어서, 삽입, 삭제, 검색 등의 연산이 평균 및 최악의 경우 모두 \(O(\log n)\)의 시간 복잡도를 가집니다.

---

### **주요 특징**

1. **자동 정렬**  
   - `map`에 저장되는 모든 원소는 **키(key)**를 기준으로 오름차순(기본)으로 정렬됩니다.
   - 만약 다른 정렬 기준이 필요하면, 사용자 정의 비교 함수를 제공할 수 있습니다.

2. **키의 중복 금지**  
   - `map`은 각 키가 **유일(unique)** 합니다.
   - 만약 동일한 키로 삽입을 시도하면 기존 값이 업데이트되거나 삽입이 거부됩니다.

3. **검색/삽입/삭제**  
   - 내부 자료구조가 균형 이진 탐색 트리이므로, 이러한 연산들이 평균 및 최악의 경우 \(O(\log n)\)에 수행됩니다.
   - 키를 사용하여 값에 빠르게 접근할 수 있습니다.

4. **반복자(iterator)**  
   - `map`은 반복자를 사용하여 원소들을 순회할 수 있으며, 이 때 원소들은 키의 정렬 순서대로 접근됩니다.

---

### **유사한 자료구조와의 비교**

1. **`unordered_map`**  
   - **구현**: 해시 테이블(Hash Table) 기반으로 구현됩니다.
   - **정렬 여부**: 원소들이 순서 없이 저장되며, 삽입 순서나 정렬된 순서가 보장되지 않습니다.
   - **시간 복잡도**: 평균 \(O(1)\) (최악의 경우 \(O(n)\))의 시간 복잡도를 가집니다.
   - **사용 용도**: 빠른 검색, 삽입, 삭제가 필요할 때 유용하며, 원소의 순서가 중요하지 않을 때 사용합니다.
   
2. **`multimap`**  
   - **구현**: `map`과 같이 균형 이진 탐색 트리로 구현됩니다.
   - **정렬 여부**: 키를 기준으로 정렬되어 저장됩니다.
   - **키 중복 허용**: `multimap`은 동일한 키를 여러 번 저장할 수 있습니다.
   - **사용 용도**: 하나의 키에 대해 여러 값을 저장해야 할 때 사용합니다.

3. **`set`과 `multiset`**  
   - **구현**: 이들은 `map`과 매우 유사하지만, 키만 저장하고 값은 따로 저장하지 않습니다.
   - **특징**: `set`은 중복을 허용하지 않고, `multiset`은 중복을 허용합니다.
   - **용도**: 정렬된 유일한 원소 집합(또는 중복 허용)을 관리할 때 사용합니다.

4. **`vector`와 같은 순차 컨테이너**  
   - **특징**: 순차 컨테이너는 인덱스 기반의 접근이 가능하지만, 자동 정렬이나 키-값 쌍 저장 기능은 없습니다.
   - **용도**: 데이터의 순서를 유지하면서 빠른 임의 접근이 필요할 때 사용합니다.
   - **비교**: 만약 연관 검색이나 자동 정렬이 필요하다면 `map`이나 `unordered_map`을 사용하는 것이 적합합니다.

---

### **요약**

- **`map`**: 키-값 쌍을 정렬된 순서로 저장, 각 키는 유일, 모든 연산이 \(O(\log n)\)  
- **`unordered_map`**: 키-값 쌍을 해시 기반으로 저장, 정렬되지 않음, 평균 \(O(1)\)  
- **`multimap`**: `map`과 유사하나, 중복 키를 허용  
- **`set`/`multiset`**: 값만 저장, 정렬되어 있음; 중복 여부에 따라 선택

각 컨테이너는 문제의 요구사항에 따라 적절하게 선택되어야 하며,  
예를 들어 **정렬된 상태의 빠른 검색**이 필요하면 `map`이나 `set`을,  
**최고의 검색 속도**가 필요하면서 순서는 중요하지 않다면 `unordered_map`이나 `unordered_set`을 사용합니다.
