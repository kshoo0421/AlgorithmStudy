# 백트래킹 알고리즘
- 바킹독의 강의 : [백트래킹 알고리즘](https://youtu.be/Enz2csssTCs?si=fjqVJ6Do5XMBM-4T)<br>

백트래킹 알고리즘은 각 단계를 차례로 확인해보고 최적의 결과를 찾는 알고리즘입니다.<br>
정답이 나온다면 알고리즘을 종료하며, 정답이 아니라면 다시 이전 단계로 돌아가 알고리즘을 진행합니다.<br>

---
백트래킹(Backtracking)은 문제 해결을 위해 가능한 모든 경우의 수(해답 후보)를 체계적으로 탐색하는 알고리즘 설계 기법입니다.  
기본 아이디어는 **깊이 우선 탐색(DFS)**를 수행하면서, 현재까지의 선택이 문제의 조건에 부합하지 않거나 최적해로 이어질 가능성이 없다고 판단되면 **즉시 되돌아가(Backtrack)** 다른 선택을 시도하는 것입니다.

### 백트래킹의 주요 개념
- **부분해(solution candidate)의 구성**:  
  문제를 여러 단계로 나누고, 각 단계에서 가능한 선택지를 하나씩 선택하여 부분해를 구성합니다.
  
- **유망성 검사(Promising check)**:  
  현재까지의 선택이 문제의 조건을 만족하는지, 그리고 앞으로의 선택으로 전체 해답을 완성할 수 있는지 판단합니다.  
  만약 불가능하다고 판단되면, 더 이상의 탐색 없이 바로 이전 단계로 돌아갑니다.

- **되돌아가기(Backtracking)**:  
  한 경로에서 해답을 찾지 못하면, 마지막에 선택했던 결정을 취소(되돌리기)하고, 다른 선택지를 시도합니다.

### 백트래킹의 특징
- **완전 탐색**:  
  조건을 만족하는 모든 해답을 찾거나, 최적해를 찾기 위해 가능한 모든 경우를 탐색합니다.
- **가지치기(pruning)**:  
  유망성 검사를 통해 더 이상 해답이 될 가능성이 없는 부분 경로는 미리 제외함으로써 탐색 공간을 줄이고 효율을 높입니다.
- **재귀적 구현**:  
  보통 재귀 함수를 통해 구현되며, 각 재귀 호출은 선택지 중 하나를 결정하고 다음 단계로 넘어갑니다.

### 백트래킹의 활용 예시
- **순열, 조합 생성**:  
  예를 들어, N개의 원소에서 모든 순열이나 조합을 생성할 때 백트래킹을 사용합니다.
- **그래프 색칠 문제, 스도쿠**:  
  제한 조건에 맞춰 색칠하거나 숫자를 배치할 때, 조건에 맞지 않는 경우 되돌아가는 방식으로 해결할 수 있습니다.
- **부분집합 문제**:  
  집합의 모든 부분집합을 생성하는 경우 등에도 활용됩니다.

### 장점과 단점
- **장점**:  
  - 구현이 직관적이며, 문제의 조건을 명확히 표현할 수 있습니다.
  - 가지치기를 통해 탐색 공간을 효과적으로 줄일 수 있습니다.
- **단점**:  
  - 최악의 경우 가능한 모든 경우를 탐색하므로, 경우의 수가 많으면 시간 복잡도가 매우 커질 수 있습니다.
  - 효율적인 가지치기 방법을 찾지 못하면 실제 문제에서 시간 초과가 발생할 수 있습니다.

### 예시 코드 (C++)
아래 코드는 1부터 N까지의 순열을 생성하는 간단한 백트래킹 예시입니다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

void backtrack(vector<int>& perm, vector<bool>& used, int N) {
    if (perm.size() == N) {
        for (int x : perm)
            cout << x << " ";
        cout << "\n";
        return;
    }
    for (int i = 1; i <= N; i++){
        if (!used[i]) {
            used[i] = true;
            perm.push_back(i);
            backtrack(perm, used, N);
            perm.pop_back();
            used[i] = false;
        }
    }
}

int main(){
    int N;
    cin >> N;
    vector<int> perm;
    vector<bool> used(N+1, false);
    backtrack(perm, used, N);
    return 0;
}
```

이 코드는 1부터 N까지의 모든 순열을 생성하고 출력합니다.  
각 단계마다 아직 사용되지 않은 숫자를 선택하고, 재귀 호출 후에는 선택을 취소(백트래킹)하여 다른 경우를 탐색합니다.

---

요약하면, **백트래킹은**  
- 문제를 여러 단계로 나누어 한 단계씩 선택하면서 해답을 구성하고,  
- 조건에 맞지 않는 경우 바로 이전 단계로 돌아가 다른 선택을 시도하는 방법입니다.  
이 방법은 **완전 탐색**을 보장하지만, 효율적인 가지치기를 통해 탐색 공간을 줄이는 것이 핵심입니다.
---