# 위상정렬 알고리즘
- 바킹독의 강의 : [위상정렬 알고리즘](https://youtu.be/Th-gLZUrd04?si=nSpe5j_IWE20roUe)<br>

`위상 정렬`은 선행 조건을 완료한 후 뒤 다음 단계를 진행하는 알고리즘입니다.<br>
방향 그래프의 일종으로 생각하면 편합니다.<br>

`in-degree`라고 하는 진입차수가 중요합니다.<br>

---

위상 정렬(Topological Sort)은 **방향 그래프**(Directed Graph), 특히 **사이클이 없는 유향 그래프 (DAG)**에서 노드들을 **순서대로 나열하는 알고리즘**입니다.  
즉, 모든 간선 \(u \to v\)에 대해, 노드 \(u\)가 \(v\)보다 먼저 오도록 정렬하는 것입니다.

---

### 주요 개념

1. **DAG (Directed Acyclic Graph)**  
   - 위상 정렬은 반드시 **사이클이 없는 방향 그래프**(DAG)에서만 적용할 수 있습니다.
   - 만약 사이클이 존재한다면, 위상 정렬은 정의되지 않습니다.

2. **정점의 진입차수(In-degree)**  
   - 한 정점으로 들어오는 간선의 수를 의미합니다.
   - 위상 정렬의 핵심 아이디어 중 하나는, **진입차수가 0인 정점부터 정렬**하는 것입니다.
   - 진입차수가 0인 정점은 다른 노드에서 현재 노드로 가는 간선이 없으므로, 제일 먼저 올 수 있습니다.

3. **알고리즘의 결과**  
   - 위상 정렬은 노드들을 선형 순서로 나열하여, 모든 간선에 대해 시작점이 종료점보다 앞에 오게 합니다.
   - 이 순서는 보통 **작업 순서, 의존성 해소, 빌드 순서 결정 등**과 같이 의존성이 있는 작업을 수행할 때 활용됩니다.

---

### 구현 방식

가장 대표적으로 두 가지 방법으로 구현할 수 있습니다:

1. **Kahn의 알고리즘 (BFS 기반)**  
   - **초기화**: 모든 노드의 진입차수를 계산하고, 진입차수가 0인 노드를 큐에 넣습니다.
   - **반복**: 큐에서 한 노드를 꺼내고, 해당 노드와 연결된 모든 노드의 진입차수를 감소시킵니다.  
     진입차수가 0이 된 노드를 큐에 추가합니다.
   - **종료**: 큐가 빌 때까지 이 과정을 반복하면, 위상 정렬 순서가 생성됩니다.
   - 만약 위상 정렬 과정 중에 큐가 비어있는데 모든 노드를 방문하지 않았다면, 그래프에는 **사이클이 존재**함을 의미합니다.

2. **DFS 기반 방법**  
   - 한 노드에서 시작해 재귀적으로 DFS를 수행하면서, 방문이 끝난 노드를 스택에 넣습니다.
   - 모든 DFS가 끝난 후 스택의 원소를 꺼내면 위상 정렬 순서가 됩니다.
   - DFS 기반 방법은 일반적으로 재귀 호출을 사용하므로, 그래프의 크기가 매우 클 경우 스택 오버플로우를 주의해야 합니다.

---

### Kahn의 알고리즘 예시 (C++)

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int V, E;  // V: 정점의 수, E: 간선의 수
    cin >> V >> E;
    
    vector<vector<int>> graph(V);
    vector<int> inDegree(V, 0);
    
    // 간선 입력: u -> v
    for (int i = 0; i < E; i++){
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        inDegree[v]++;
    }
    
    queue<int> q;
    // 진입차수가 0인 모든 노드를 큐에 삽입
    for (int i = 0; i < V; i++){
        if(inDegree[i] == 0)
            q.push(i);
    }
    
    vector<int> topoOrder;
    while(!q.empty()){
        int cur = q.front();
        q.pop();
        topoOrder.push_back(cur);
        // cur와 연결된 모든 노드의 진입차수 감소
        for (int next : graph[cur]){
            inDegree[next]--;
            if(inDegree[next] == 0)
                q.push(next);
        }
    }
    
    // 만약 topoOrder의 크기가 V보다 작다면 사이클 존재
    if(topoOrder.size() != V)
        cout << "사이클이 존재합니다.\n";
    else {
        for (int node : topoOrder)
            cout << node << " ";
        cout << "\n";
    }
    
    return 0;
}
```

### 설명

- **입력**: 정점의 수 \(V\)와 간선의 수 \(E\)를 입력받고, 각 간선 \(u to v\)를 저장합니다.
- **진입차수 계산**: 각 노드에 대해 들어오는 간선의 개수를 계산해 `inDegree` 배열에 저장합니다.
- **큐 초기화**: `inDegree`가 0인 노드를 모두 큐에 넣습니다.
- **반복**: 큐에서 노드를 하나씩 꺼내면서 연결된 모든 노드의 진입차수를 감소시키고,  
  진입차수가 0이 되면 큐에 추가합니다.
- **결과 확인**: 모든 노드를 순회했으면 올바른 위상 정렬 순서가 `topoOrder`에 저장됩니다.  
  만약 일부 노드를 방문하지 못했다면, 그래프에 사이클이 존재함을 의미합니다.

---

### 요약

- **위상 정렬**은 DAG에서 **모든 간선에 대해, 시작 노드가 끝 노드보다 먼저 오도록** 노드를 정렬하는 방법입니다.
- **Kahn의 알고리즘(BFS 기반)** 과 **DFS 기반** 구현이 대표적입니다.
- 이 방법은 작업 간의 **의존 관계**를 해소하고, 여러 가지 문제(예: 빌드 순서, 작업 스케줄링)에서 활용됩니다.